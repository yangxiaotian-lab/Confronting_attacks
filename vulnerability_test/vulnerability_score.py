import matplotlib.pyplot as plt
import torchvision
import torch.utils.data
from torchvision import transforms
import numpy as np
import zipfile
import math
import sys
sys.path.append('../../')
from model import model
import os

plt.rcParams['font.sans-serif'] = ['SimHei']
plt.rcParams['axes.unicode_minus'] = False

BATCH_SIZE = 1
os.environ['CUDA_VISIBLE_DEVICE'] = '0'

img_transform = transforms.Compose([transforms.Resize((112, 112)),
                                    transforms.ToTensor(),
                                    transforms.Normalize(mean=(0.5, 0.5, 0.5), std=(0.5, 0.5, 0.5))])


def write_res(file_path, ans_dict):
    f = open(file_path, 'r')
    con = f.readlines()
    f.close()

    con = np.array(con)
    # 用来保存文件内数据的字典
    file_dict = {}

    for i in con:
        cur = i.strip('\n')
        # 获取文件中已经存在的key和value，写入字典
        key = cur.split('=')[0]
        value = cur.split('=')[1]
        file_dict[key] = value

    file_dict.update(ans_dict)

    f = open(file_path, 'w')
    for i in file_dict.keys():
        key = i
        value = file_dict[key]
        f.write(key + '={}'.format(value) + '\n')
    f.close()


def get_succ_loss(net, loader_ori, loader_test):
    attack_succ = 0
    for step, (ori, test) in enumerate(zip(loader_ori, loader_test)):
        with torch.no_grad():
            ori_feature = net(ori[0].cuda())
            test_feature = net(test[0].cuda())
            cos_ori = ori_feature / torch.norm(ori_feature, dim=1).unsqueeze(1)
            cos_test = test_feature / torch.norm(test_feature, dim=1).unsqueeze(1)

        score = 0.5 * (torch.sum(cos_ori * cos_test, dim=1) + 1)
        attack_succ += sum((score < 0.8).int()).item()

        # print("第" + str(step) + "批测试样本得分计算完成")

    return attack_succ / 150


if __name__ == '__main__':
    # 模型加载
    featuresNum = 512
    net = model.MobileFacenet(featuresNum)  # mobileFace

    ckpt = torch.load("../../model/mobileFace-ArcFace.ckpt")
    net.load_state_dict(ckpt['net_state_dict'])
    print('----------------------------加载MobileFace模型----------------------------')
    net = net.cuda()
    net.eval()

    data_ori = '../../dataset'
    print('加载的数据集为: ', data_ori)
    case_ori = torchvision.datasets.ImageFolder(data_ori, img_transform)
    loader_ori = torch.utils.data.DataLoader(case_ori, num_workers=16, batch_size=BATCH_SIZE, shuffle=False,
                                             drop_last=False)

    # 读数据集列表 循环数据集
    antijam_dir = '../../output/antijam_data/'
    antijam_attack_succ = []
    antijam_dirs = os.listdir(antijam_dir)
    for single_cases_name in antijam_dirs:
        single_cases_path = os.path.join(antijam_dir, single_cases_name)  # antijam_data/block
        print("当前数据集名称为: " + single_cases_name)
        single_attack_succ = []
        single_case_dirs = os.listdir(single_cases_path)
        no = 0
        for single_case_name in single_case_dirs:
            single_case_path = os.path.join(single_cases_path, single_case_name)  # antijam_data/block/block_10

            # 使用dataloader读取数据集
            case_test = torchvision.datasets.ImageFolder(single_case_path, img_transform)
            loader_test = torch.utils.data.DataLoader(case_test, num_workers=1, batch_size=BATCH_SIZE, shuffle=False,
                                                      drop_last=False)

            attack_succ = get_succ_loss(net, loader_ori, loader_test)
            single_attack_succ.append(attack_succ)
            print("数据集" + str(no) + "漏洞检出率%.2f%%" % (attack_succ * 100))
            no = no + 1

        curr_attack_succ = np.mean(single_attack_succ)
        print("平均数据集漏洞检出率: " + str(curr_attack_succ) + '\n')
        antijam_attack_succ.append(curr_attack_succ)

    mean_antijam_as = np.mean(antijam_attack_succ)
    print("漏洞检出率%.2f%%" % (mean_antijam_as * 100))

    # 写入数据
    vulnerability_score = round(((math.pow(100000, 1 - mean_antijam_as) - 1) / (100000 - 1)) * 100, 2)
    ans_dict = {"vulnerability_score": vulnerability_score}
    write_res("../../res/result.txt", ans_dict)

